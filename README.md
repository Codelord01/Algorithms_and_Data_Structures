This is all about Data Structures and Algorithms using C and Python to implement them. I used a book called 'Data Structures and Algorithms Made Easy' by Narasimha Karumanchi along with so many youtube vidoes and online resources. The outline I followed is below;
1. Introduction
1.1Variables
1.2Data Types
1.3
1.4Data Structures
Abstract Data Types (ADTs)
1.5What is an Algorithm?
1.6
1.7Why the Analysis of Algorithms?
Goal of the Analysis of Algorithms
1.8What is Running Time Analysis?
1.9How to Compare Algorithms
1.10 What is Rate of Growth?
1.11 Commonly Used Rates of Growth
1.12 Types of Analysis
1.13 Asymptotic Notation
1.14 Big-O Notation [Upper Bounding Function]
1.15 Omega-Q Notation [Lower Bounding Function]
1.16 Theta-Î˜ Notation [Order Function]
1.17 Important Notes
1.18 Why is it called Asymptotic Analysis?
1.19 Guidelines for Asymptotic Analysis
1.20 Simplyfying properties of asymptotic notations
1.21 Commonly used Logarithms and Summations
1.22 Master Theorem for Divide and Conquer Recurrences
1.23 Divide and Conquer Master Theorem: Problems & Solutions
1.24 Master Theorem for Subtract and Conquer Recurrences
1.25 Variant of Subtraction and Conquer Master Theorem
1.26 Method of Guessing and Confirming1.27 Amortized Analysis
1.28 Algorithms Analysis: Problems & Solutions
2. Recursion and Backtracking
2.1
2.2Introduction
What is Recursion?
2.3Why Recursion?
2.4
2.5Format of a Recursive Function
Recursion and Memory (Visualization)
2.6Recursion versus Iteration
2.7Notes on Recursion
2.8
2.9Example Algorithms of Recursion
Recursion: Problems & Solutions
2.10 What is Backtracking?
2.11 Example Algorithms of Backtracking
2.12 Backtracking: Problems & Solutions
3. Linked Lists
3.1 What is a Linked List?
3.2Linked Lists ADT
3.3Why Linked Lists?
3.4
3.5Arrays Overview
Comparison of Linked Lists with Arrays & Dynamic Arrays
3.6Singly Linked Lists
3.7
3.8Doubly Linked Lists
Circular Linked Lists
3.9A Memory-efficient Doubly Linked List
3.10 Unrolled Linked Lists
3.11 Skip Lists
3.12 Linked Lists: Problems & Solutions
4. Stacks
4.1What is a Stack?
4.2How Stacks are used
4.3Stack ADT4.4Applications
4.5
4.6Implementation
Comparison of Implementations
4.7Stacks: Problems & Solutions
5. Queues
5.1What is a Queue?
5.2
5.3How are Queues Used?
Queue ADT
5.4Exceptions
5.5Applications
5.6
5.7Implementation
Queues: Problems & Solutions
6. Trees
6.1 What is a Tree?
6.2Glossary
6.3
6.4Binary Trees
Types of Binary Trees
6.5Properties of Binary Trees
6.6Binary Tree Traversals
6.7
6.8Generic Trees (N-ary Trees)
Threaded Binary Tree Traversals (Stack or Queue-less Traversals)
6.9Expression Trees
6.10 XOR Trees
6.11 Binary Search Trees (BSTs)
6.12
Balanced Binary Search Trees
6.13 AVL (Adelson-Velskii and Landis) Trees
6.14 Other Variations on Trees
7. Priority Queues and Heaps
7.1 What is a Priority Queue?
7.2Priority Queue ADT
7.3Priority Queue Applications
7.4Priority Queue Implementations7.5Heaps and Binary Heaps
7.6
7.7Binary Heaps
Heapsort
7.8Priority Queues [Heaps]: Problems & Solutions
8. Disjoint Sets ADT
8.1Introduction
8.2
8.3Equivalence Relations and Equivalence Classes
Disjoint Sets ADT
8.4Applications
8.5Tradeoffs in Implementing Disjoint Sets ADT
8.8
8.9Fast UNION Implementation (Slow FIND)
Fast UNION Implementations (Quick FIND)
8.10 Summary
8.11 Disjoint Sets: Problems & Solutions
9. Graph Algorithms
9.1
9.2Introduction
Glossary
9.3Applications of Graphs
9.4Graph Representation
9.5
9.6Graph Traversals
Topological Sort
9.7Shortest Path Algorithms
9.8
9.9Minimal Spanning Tree
Graph Algorithms: Problems & Solutions
10. Sorting
10.1 What is Sorting?
10.2Why is Sorting Necessary?
10.3
10.4Classification of Sorting Algorithms
Other Classifications
10.5Bubble Sort
10.6Selection Sort
10.7Insertion Sort10.8
Shell Sort
10.9 Merge Sort
10.10 Heap Sort
10.11 Quick Sort
10.12 Tree Sort
10.13 Comparison of Sorting Algorithms
10.14 Linear Sorting Algorithms
10.15 Counting Sort
10.16 Bucket Sort (or Bin Sort)
10.17 Radix Sort
10.18 Topological Sort
10.19 External Sorting
10.20 Sorting: Problems & Solutions
11. Searching
11.1
11.2What is Searching?
Why do we need Searching?
11.3Types of Searching
11.4
11.5Unordered Linear Search
Sorted/Ordered Linear Search
11.6Binary Search
11.7Interpolation Search
11.8
11.9Comparing Basic Searching Algorithms
Symbol Tables and Hashing
11.10 String Searching Algorithms
11.11 Searching: Problems & Solutions
12. Selection Algorithms [Medians]
12.1
12.2What are Selection Algorithms?
Selection by Sorting
12.3Partition-based Selection Algorithm
12.4
12.5Linear Selection Algorithm - Median of Medians Algorithm
Finding the K Smallest Elements in Sorted Order
12.6Selection Algorithms: Problems & Solutions13. Symbol Tables
13.1
13.2Introduction
What are Symbol Tables?
13.3Symbol Table Implementations
13.4Comparison Table of Symbols for Implementations
14. Hashing
14.1
14.2What is Hashing?
Why Hashing?
14.3HashTable ADT
14.4Understanding Hashing
14.5
14.6Components of Hashing
Hash Table
14.7Hash Function
14.8Load Factor
14.9 Collisions
14.10 Collision Resolution Techniques
14.11 Separate Chaining
14.12 Open Addressing
14.13 Comparison of Collision Resolution Techniques
14.14 How Hashing Gets O(1) Complexity?
14.15 Hashing Techniques
14.16 Problems for which Hash Tables are not suitable
14.17 Bloom Filters
14.18 Hashing: Problems & Solutions
15. String Algorithms
15.1Introduction
15.2
15.3String Matching Algorithms
Brute Force Method
15.4Rabin-Karp String Matching Algorithm
15.5
15.6String Matching with Finite Automata
KMP Algorithm
15.7Boyer-Moore Algorithm15.8
Data Structures for Storing Strings
15.9 Hash Tables for Strings
15.10 Binary Search Trees for Strings
15.11 Tries
15.12 Ternary Search Trees
15.13 Comparing BSTs, Tries and TSTs
15.14 Suffix Trees
15.15 String Algorithms: Problems & Solutions
16. Algorithms Design Techniques
16.1Introduction
16.2
16.3Classification
Classification by Implementation Method
16.4Classification by Design Method
16.5Other Classifications
17. Greedy Algorithms
17.1
17.2Introduction
Greedy Strategy
17.3Elements of Greedy Algorithms
17.4Does Greedy Always Work?
17.5
17.6Advantages and Disadvantages of Greedy Method
Greedy Applications
17.7Understanding Greedy Technique
17.8Greedy Algorithms: Problems & Solutions
18. Divide and Conquer Algorithms
18.1
18.2Introduction
What is the Divide and Conquer Strategy?
18.3Does Divide and Conquer Always Work?
18.4
18.5Divide and Conquer Visualization
Understanding Divide and Conquer
18.6Advantages of Divide and Conquer
18.7Disadvantages of Divide and Conquer
18.8Master Theorem18.9
Divide and Conquer Applications
18.10 Divide and Conquer: Problems & Solutions
19. Dynamic Programming
19.1
19.2Introduction
What is Dynamic Programming Strategy?19.3Properties of Dynamic Programming Strategy
19.4
19.5Can Dynamic Programming Solve All Problems?
Dynamic Programming Approaches
19.6Examples of Dynamic Programming Algorithms
19.7Understanding Dynamic Programming
19.8
19.9Longest Common Subsequence
Dynamic Programming: Problems & Solutions
20. Complexity Classes
20.1 Introduction
20.2Polynomial/Exponential Time
20.3
20.4What is a Decision Problem?
Decision Procedure
20.5What is a Complexity Class?
20.6Types of Complexity Classes
20.7
20.8Reductions
Complexity Classes: Problems & Solutions
21. Miscellaneous Concepts
21.1Introduction
21.2Hacks on Bit-wise Programming
21.3Other Programming Questions
